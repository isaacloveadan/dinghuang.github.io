---
layout: default
title:  "设计模式"
date:   2018-07-18 09:43:00
categories: main
---
目录
==

* TOC
{:toc}

[菜鸟教程文档](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)

#   设计模式

设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。


1.创建型模式
--------------------------------------------------
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
### 1.1. 工厂模式

**主要解决**：主要解决接口选择的问题。

**何时使用**：我们明确地计划不同条件下创建不同实例时。

**优点**：
 1. 一个调用者想创建一个对象，只要知道其名称就可以了
 2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以
 3. 屏蔽产品的具体实现，调用者只关心产品的接口

**缺点**：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

**如何解决**：让其子类实现工厂接口，返回的也是一个抽象的产品。

**使用场景**： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

**注意事项**：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

```
public interface Car {
    void run();
}

public class ExpensiveCar implements Car {
    @Override
    public void run() {
        System.out.println("expensiveCar.run");
    }
}

public class LitterCar implements Car {

    @Override
    public void run() {
        System.out.println("littleCard.run");
    }
}

public class CarFactory {
    public Car getCar(String type) {
        if (type == null) {
            return null;
        }
        if (type.equals("litterCar")) {
            return new LitterCar();
        } else if (type.equals("ExpensiveCar")) {
            return new ExpensiveCar();
        }
        return null;
    }
}
```
### 1.2. 抽象工厂模式

**主要解决**：主要解决接口选择的问题。

**何时使用**：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

**优点**：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点**：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

**使用场景**： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。

**注意事项**：产品族难扩展，产品等级易扩展。

```
public interface Car {
    void run();
}

public class ExpensiveCar implements Car {
    @Override
    public void run() {
        System.out.println("expensiveCar.run");
    }
}

public class LitterCar implements Car {

    @Override
    public void run() {
        System.out.println("littleCard.run");
    }
}

public interface Passengers {
    void getCar();
}

public class Man implements Passengers {
    @Override
    public void getCar() {
        System.out.println("man.getCar");
    }
}

public class Woman implements Passengers {
    @Override
    public void getCar() {
        System.out.println("man.getCar");
    }
}

public abstract class AbstractFactory {
    public abstract Passengers getPassengers(String user);
    public abstract Car getCar(String car);
}

public class CarFactory extends AbstractFactory{
    @Override
    public Passengers getPassengers(String user) {
        return null;
    }

    @Override
    public Car getCar(String type) {
        if (type == null) {
            return null;
        }
        if (type.equals("litterCar")) {
            return new LitterCar();
        } else if (type.equals("ExpensiveCar")) {
            return new ExpensiveCar();
        }
        return null;
    }
}


public class PassengerFactory extends AbstractFactory {
    @Override
    public Passengers getPassengers(String user) {
        if (user == null) {
            return null;
        }
        if (user.equals("man")) {
            return new Man();
        } else if (user.equals("woman")) {
            return new Woman();
        }
        return null;
    }

    @Override
    public Car getCar(String car) {
        return null;
    }
}

public class FactoryProducer {
    public static AbstractFactory getFactory(String choice) {
        if (choice.equalsIgnoreCase("Car")) {
            return new CarFactory();
        } else if (choice.equalsIgnoreCase("Passenger")) {
            return new PassengerFactory();
        }
        return null;
    }
}

```
### 1.3. 单例模式

**主要解决**：一个全局使用的类频繁地创建与销毁。

**何时使用**：当您想控制实例数目，节省系统资源的时候。

**优点**：
 1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）
 2. 避免对资源的多重占用（比如写文件操作）

缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**使用场景**：
 1. 要求生产唯一序列号。
 2. WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
 3. 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。

**注意事项**：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。

```
/**
 * 饿汉式
 * 是否 Lazy 初始化：否
 * <p>
 * 是否多线程安全：是
 * <p>
 * 实现难度：易
 * <p>
 * 描述：这种方式比较常用，但容易产生垃圾对象。
 * 优点：没有加锁，执行效率会提高。
 * 缺点：类加载时就初始化，浪费内存。
 * 它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多
 * 种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，
 * 这时候初始化 instance 显然没有达到 lazy loading 的效果。
 *
 * @author dinghuang123@gmail.com
 * @since 2018/7/18
 */
public class User {

    private static User user = new User();

    //让构造函数私有化，这样该类不会被实例化
    private User() {
    }

    public static User getUser() {
        return user;
    }

    public void showMessage() {
        System.out.println("What???");
    }
}

/**
 * 懒汉式，线程不安全
 * 是否 Lazy 初始化：是
 * <p>
 * 是否多线程安全：否
 * <p>
 * 实现难度：易
 * <p>
 * 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。
 * 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。
 *
 * @author dinghuang123@gmail.com
 * @since 2018/7/18
 */
public class User {

    private static User user;
    
    //让构造函数私有化，这样该类不会被实例化
    private User() {
    }

    public static User getUser() {
        if (user == null) {
            System.out.println("no user");
            user = new User();
        }
        return user;
    }

    public void showMessage() {
        System.out.println("What???");
    }
}

/**
 * 懒汉式，线程安全
 * 是否 Lazy 初始化：是
 * <p>
 * 是否多线程安全：是
 * <p>
 * 实现难度：易
 * <p>
 * 描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。
 * 优点：第一次调用才初始化，避免内存浪费。
 * 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。
 * getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。
 *
 * @author dinghuang123@gmail.com
 * @since 2018/7/18
 */
public class User {

    private static User user;

    //让构造函数私有化，这样该类不会被实例化
    private User() {
    }

    public static synchronized User getUser() {
        if (user == null) {
            System.out.println("no User");
            user = new User();
        }
        return user;
    }

    public void showMessage() {
        System.out.println("What???");
    }
}

/**
 * 双检锁/双重校验锁（DCL，即 double-checked locking）
 * JDK 版本：JDK1.5 起
 * <p>
 * 是否 Lazy 初始化：是
 * <p>
 * 是否多线程安全：是
 * <p>
 * 实现难度：较复杂
 * <p>
 * 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
 * getInstance() 的性能对应用程序很关键。
 *
 * @author dinghuang123@gmail.com
 * @since 2018/7/18
 */
public class User {

    private static User user;

    //让构造函数私有化，这样该类不会被实例化
    private User() {
    }

    public static User getUser() {
        if (user == null) {
            synchronized (User.class) {
                if (user == null) {
                    System.out.println("no User");
                    user = new User();

                }
            }
        }
        return user;
    }

    public void showMessage() {
        System.out.println("What???");
    }
}

/**
 * 登记式/静态内部类
 * 是否 Lazy 初始化：是
 * <p>
 * 是否多线程安全：是
 * <p>
 * 实现难度：一般
 * <p>
 * 描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式
 * 。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。
 * 这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：
 * 第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果）
 * ，而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，
 * 只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，
 * 如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载
 * 时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实
 * 例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。
 *
 * @author dinghuang123@gmail.com
 * @since 2018/7/18
 */
public class User {

    private static class UserHolder {
        private static final User user = new User();
    }

    private User() {
    }

    public static final User getUser() {
        return UserHolder.user;
    }

}


public class SingletonTest {
    public static void main(String[] args) {
        //不合法的构造函数
        //编译时错误：构造函数 User() 是私有的
//        User user = new User();
        Runnable runnable = () -> {
            //枚举单例
//          User.USER.sendMessage();
            User user = User.getUser();
            user.showMessage();
        };
        IntStream.range(0, 100)
                .forEach(i -> {
                    Thread thread = new Thread(runnable);
                    thread.start();
                });

    }
}

```
一般情况下，不建议使用懒汉方式，建议使用饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用登记方式。如果涉及到反序列化创建对象时，可以尝试使用枚举方式。如果有其他特殊的需求，可以考虑使用双检锁方式。

### 1.4. 建造者模式

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

**主要解决**：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

**何时使用**：一些基本部件不会变，而其组合经常变化的时候。

**如何解决**：将变与不变分离开。

**应用实例**：
 1. 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"
 2. JAVA 中的 StringBuilder

**优点**： 
 1. 建造者独立，易扩展
 2. 便于控制细节风险

**缺点**：
 1. 产品必须有共同点，范围有限制
 2. 如内部变化复杂，会有很多的建造类

**使用场景**： 
 1. 需要生成的对象具有复杂的内部结构
 2. 需要生成的对象内部属性本身相互依赖

**注意事项**：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。

```
public interface Product {
    public String name();
    public float price();
    public Production production();
}


public interface Production {

    public String production();
}

public class Hand implements Production{

    @Override
    public String production() {
        return "hand";
    }
}

public class Machine implements Production {
    @Override
    public String production() {
        return "Machine";
    }
}

public abstract class Windows implements Product{

    @Override
    public Production production(){
        return new Hand();
    }

    @Override
    public abstract float price();
}

public abstract class Mac implements Product{
    @Override
    public Production production(){
        return new Machine();
    }

    @Override
    public abstract float price();
}

public class WindowsSystem extends Windows{
    @Override
    public String name() {
        return "windowsSystem";
    }

    @Override
    public float price() {
        return 25.0f;
    }
}

public class MacSystem extends Mac {
    @Override
    public String name() {
        return "macSystem";
    }

    @Override
    public float price() {
        return 30.0f;
    }
}

public class SystemProduct {

    private List<Product> products = new ArrayList<>();

    public void addProduct(Product product) {
        products.add(product);
    }

    public float getCost() {
        float cost = 0.0f;
        for (Product product : products) {
            cost += product.price();
        }
        return cost;
    }

    public void showProducts() {
        for (Product product : products) {
            System.out.print("Product : " + product.name());
            System.out.print(",Production : " + product.production().production());
            System.out.println(", Price : " + product.price());
        }
    }
}

public class SystemProductBuilder {

    public SystemProduct prepareMacSystem() {
        SystemProduct systemProduct = new SystemProduct();
        systemProduct.addProduct(new MacSystem());
        return systemProduct;
    }

    public SystemProduct prepareWindowsSystem() {
        SystemProduct systemProduct = new SystemProduct();
        systemProduct.addProduct(new WindowsSystem());
        return systemProduct;
    }
}

public class BuilderTest {
    public static void main(String[] args) {
        SystemProductBuilder systemProductBuilder = new SystemProductBuilder();
        SystemProduct windows = systemProductBuilder.prepareMacSystem();
        System.out.println("windows product");
        windows.showProducts();
        System.out.println("Total Cost: " + windows.getCost());

        SystemProduct allSystem = systemProductBuilder.prepareAllSystem();
        System.out.println("allSystem");
        allSystem.showProducts();
        System.out.println("Total Cost: " + allSystem.getCost());
    }
}

```
### 1.5. 原型模式

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

**主要解决**：在运行期建立和删除原型。

**何时使用**： 
 1. 当一个系统应该独立于它的产品创建，构成和表示时
 2. 当要实例化的类是在运行时刻指定时，例如，通过动态装载
 3. 为了避免创建一个与产品类层次平行的工厂类层次时
 4. 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些

**如何解决**：利用已有的一个原型对象，快速地生成和原型对象一样的实例。

**应用实例**：
 1. 细胞分裂
 2. JAVA 中的 Object clone() 方法

**优点**： 
 1. 性能提高
 2. 逃避构造函数的约束

**缺点**：
 1. 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候
 2. 必须实现 Cloneable 接口

**使用场景**： 
 1. 资源优化场景
 2. 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等 性能和安全要求的场景
 3. 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式 一个对象多个修改者的场景
 4. 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用
 5. 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone
    的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用

**注意事项**：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。
```
/**
 * 创建一个抽象类 Prototype 和扩展了 Prototype 类的实体类。下一步是定义类 PrototypeCache，该类把 Prototype
 * 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。
 *
 * @author dinghuang123@gmail.com
 * @since 2018/7/18
 */
public abstract class Prototype implements Cloneable{

    private String id;

    private String type;

    abstract void operation();

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    @Override
    public Object clone(){
        Object clone = null;
        try{
            clone = super.clone();
        }catch (CloneNotSupportedException e){
            e.printStackTrace();
        }
        return clone;
    }
}

public class PrototypeOne extends Prototype {

    public PrototypeOne(){
        type = "prototypeOne";
    }

    @Override
    void operation() {
        System.out.println("Inside PrototypeOne::draw() method.");
    }
}

public class PrototypeTwo extends Prototype {

    public PrototypeTwo() {
        type = "prototypeTwo";
    }

    @Override
    void operation() {
        System.out.println("Inside PrototypeTwo::draw() method.");
    }
}

public class PrototypeCache {

    private static Hashtable<String,Prototype> propertyMap =
            new Hashtable<>();

    public static Prototype getProperType(String id){
        Prototype cachePrototype = propertyMap.get(id);
        return (Prototype) cachePrototype.clone();
    }

    public static void loadCache() {
        PrototypeOne prototypeOne = new PrototypeOne();
        prototypeOne.setId("1");
        propertyMap.put(prototypeOne.getId(),prototypeOne);
        PrototypeTwo prototypeTwo = new PrototypeTwo();
        prototypeTwo.setId("2");
        propertyMap.put(prototypeTwo.getId(),prototypeTwo);
    }
}

public class PrototypeTest {

    public static void main(String[] args) {
        PrototypeCache.loadCache();
        PrototypeOne prototypeOne = (PrototypeOne) PrototypeCache.getProperType("1");
        System.out.println("Prototype : " + prototypeOne.getType());
        PrototypeTwo prototypeTwo = (PrototypeTwo) PrototypeCache.getProperType("2");
        System.out.println("Prototype : " + prototypeTwo.getType());
    }
}
```
2.结构型模式
--------------------------------------------------
这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。

### 2.1. 适配器模式
适配器模式。。。。待更新